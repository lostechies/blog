---
wordpress_id: 166
title: Reacting to change
date: 2008-04-08T00:11:10+00:00
author: Jimmy Bogard
layout: post
wordpress_guid: /blogs/jimmy_bogard/archive/2008/04/07/reacting-to-change.aspx
dsq_thread_id:
  - "264715645"
categories:
  - Agile
---
When dealing with the possibility of change in requirements in the middle of development, I&#8217;ve generally seen three reactions:

  * Explicitly reject the possibility
  * Ignore it completely, hope it goes away
  * Accept and embrace it

Of these three, only two are valid reactions.&nbsp; There&#8217;s a time for explicit rejection of new requirements, even in Agile and iterative development.&nbsp; Unfortunately, most of the places I&#8217;ve encountered fall into the middle bucket, ignoring new requirements or actively subverting those expressing them.

### Explicit rejection

There&#8217;s nothing wrong with explicit rejection of new requirements.&nbsp; In iterative development, once the stories have been selected for an iteration, no new stories can be added to that iteration.&nbsp; Stories are often split during planning, and sometimes new stories are surfaced during an iteration.&nbsp; Agile teams have to be disciplined not to take on new work during an iteration, as this can jeopardize finishing the original stories selected.

By keeping iterations short (1-2 weeks), business owners never feel too bad about new requirements (and eventually stories) being surfaced.&nbsp; It&#8217;s a natural part of the development process.&nbsp; As software is delivered incrementally, assumptions are challenged and directions can change.&nbsp; But not during an iteration, as the team needs stable direction towards a defined goal.

Explicit rejection also occurs in phased-based development.&nbsp; I&#8217;m moving away from the term &#8220;waterfall&#8221;, as it&#8217;s beginning to be a loaded term.&nbsp; Instead, think hand-offs, sign-offs, and phases (planning, development, testing, delivery, etc.)&nbsp; Changes in requirements are explicitly rejected during the development phase, but the realities of software development tend to force compromises in this area.&nbsp; This can lead to contentious relationships between analysts and developers, as each tries to maneuver and politic to get their way.

The way I&#8217;ve seen this go down is usually developers will assign very high estimates on items surfaced late in the game, so that those signing the checks can&#8217;t justify the new features getting added.&nbsp; Then it becomes a trick of the analysts to ask for 100 features all with &#8220;Must Have&#8221; priority, with the full knowledge that only 10 will actually get delivered.

### Ignore and hope

Explicit rejection in phase-based processes lead to ignoring and hoping changes don&#8217;t come in.&nbsp; There are plenty of ways to ignore change requests, such as ignoring emails and dismissing changes out-of-hand.&nbsp; Even explicit rejection is a form of ignoring, as it ignores the reality of software development.&nbsp; As soon as a user sees the software for the first time, all presumptions of usability are thrown out the window.

Teams hope for no change requests by filling their plate as much as possible, so even the slightest deviation from the plan would cause delivery delays.&nbsp; If change requests do come in, I&#8217;ve seen software teams keep track of them, for ammunition in later &#8220;blamestorming&#8221; meetings.

We can hope change requests won&#8217;t happen by attempting to design as long as possible up front.&nbsp; Elaborate UML diagrams create the illusion that if we design everything before our fingers hit the keyboard, we won&#8217;t have to worry about analysts asking for change.&nbsp; They had their chance, right?

Again, phase-based approaches lead to contentious (and even bilious) relationships between owners of each phase.&nbsp; By assuming that all decisions can be made in the design phase, it&#8217;s little more than hoping that changes won&#8217;t get requested during development.

### Accept and embrace

In iterative and incremental development, such as XP, changes are accepted and even embraced.&nbsp; Because all assumptions are shattered the moment the user uses the software for the first time, your process should take this into account.&nbsp; By allowing regular feedback, changes can be introduced, implemented and scrutinized in a very short time-frame.

It&#8217;s not all wine and roses of course, as feedback only surfaces problems, not solve them.&nbsp; But instead of ignoring or rejecting changes, you have a regular mechanism for dealing with them.&nbsp; Our team deals with changes by writing every task or story on a card.&nbsp; If it&#8217;s on a card, it can be estimated and prioritized.

Since we use cards, a change in a story takes as much effort as ripping up the incorrect story card and writing a new one.&nbsp; The less friction our process documents change requests, the more the business will be encouraged to explore new ideas.&nbsp; Nothing&#8217;s worse than a hulking software requirements tool that stifles imagination through the tedium of managing lists of requirements.

### Flexibility and Control

Since change is inevitable, we want to introduce a system that allows us to introduce change, as well as garner feedback on the effectiveness of these changes.&nbsp; But we don&#8217;t want too much change, as this will introduce unnecessary chaos and churn.

The trick is to gather and respond to enough feedback, but not too much where the team is overwhelmed and is unable to deliver.&nbsp; We want to be flexible to handle feedback from a variety of sources but control over when and how we receive it.

So how does a team perfect flexibility and control?&nbsp; With more feedback of course!&nbsp; Through regular Scrum retrospectives, a team can reflect on how they&#8217;re delivering, making small tweaks along the way.&nbsp; In the end, we want a system that can handle and respond to change to maximize the business&#8217; return on investment.