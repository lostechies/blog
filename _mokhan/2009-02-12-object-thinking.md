---
wordpress_id: 4573
title: Object Thinking
date: 2009-02-12T15:34:06+00:00
author: Mo Khan
layout: post
wordpress_guid: /blogs/mokhan/archive/2009/02/12/object-thinking.aspx
categories:
  - Books
---
I recently finished reading&#8230;

<table width="100%">
  <tr>
    <td>
      <p>
        <a href="http://www.amazon.ca/gp/product/0735619654?ie=UTF8&tag=mokhmypo-20&linkCode=as2&camp=15121&creative=330641&creativeASIN=0735619654"><img src="https://images-na.ssl-images-amazon.com/images/I/516hULBjUmL._SL160_.jpg" border="0" /> </a><img style="margin: 0px;border-top-style: none! important;border-right-style: none! important;border-left-style: none! important;border-bottom-style: none! important" height="1" alt="" src="http://www.assoc-amazon.ca/e/ir?t=mokhmypo-20&l=as2&o=15&a=0735619654" width="1" border="0" />
      </p>
    </td>
    
    <td>
      <p>
        <strong>Object Thinking</strong> <em>by David West</em>
      </p>
    </td>
  </tr>
</table>

&#160;

As usual I fold down pages that contain paragraphs that interest me&#8230; below are a few excerpts from the book that I enjoyed!

> "Better people" has been recognized as the most promising silver bullet for addressing the software crisis, and yet almost all of our energy has been spent on creating better tools, methods, and processes instead of better people?

Imagine what a team of "better people" can accomplish. Now stop imaging, and start investing in fostering cultures that cultivate "better people" all working towards the same goal.

> An unspoken but just as widely held belief that really good developers were not to be trusted &#8211; they could not be "managed", they all seemed to be "flaky" to some degree, and they did not exhibit the loyalty to company and paycheck of "normal" employees. Really "good" developers tended to be "artists", and are was (is) not a good word in the context of software development.

Those flaky artist types&#8230; \*sigh\* It&#8217;s important to allow individuals do what they are good at, that&#8217;s obviously something they like to do. It breeds innovation, and efficiency. When working in a team it&#8217;s important to be respectful of one another&#8217;s opinions and work together. 

> Every once in a while someone on the team will have a crazy idea that just might slash the complexity of the whole system. If they have courage, they&#8217;ll try it out. It will work (sometimes).

It&#8217;s important to have courage on any team. [XP teams value courage](http://mokhan.ca/blog/2007/08/31/The+Principles+And+Values+Of+XP.aspx). Without the courage to grow and challenge one another, your team will remain stagnant. By challenging one another you&#8217;re showing one another respect by saying that "I want you to get better, and I expect you to want me to get better as well"!

> Object thinking is a "crazy idea" capable of increasing simplicity in software design &#8211; crazy in the sense that it does not conform to traditional thinking about software development, crazy in the sense that it revolts against the computer thinking employed by most software developers, and crazy in many of the same ways that XP is crazy.

Trying to introduce object&#8217;s into a culture that&#8217;s firmly devoted to thinking in terms of data can seem like a crazy idea too. There is a time and place for everything, I&#8217;m sure objects aren&#8217;t great for every system. A little bit of object "thinking" can help though, I&#8217;m sure. 

> As a formalist, the computer scientist expects order and logic. The "goodness" of a program is directly proportional to the degree to which it can be formally described and formally manipulated. Proof &#8211; as in mathematical or logical proof &#8211; of correctness for a piece of software is an ultimate objective. All that is bad in software arises from deviations from formal descriptions that use precisely defined tokens and syntactic rules. Art has no place in a program. In fact, many formalists would take the extreme position: there is no such thing as art; art is nothing more than a formalism that has yet to be discovered and explicated.

Art is something that I enjoy. One of the reasons that I was drawn to software was the creative aspects of it. I first thought of developing software as a form of art. It&#8217;s great how Test Driven Development allows you to prove the correctness of a piece of software, but also enables you to refactor and be creative.

> An analogy to chess playing might illuminate the relationships among method categories. A beginning chess player follows rules and defined procedures (they are formalists), while a journeyman (informalist) relies on patterns and heuristics. A grandmaster has internalized and transcended the informal to become an aformal player.

I&#8217;m currently reading a book on [NLP](http://en.wikipedia.org/wiki/Neuro-linguistic_programming), and it describes how experts do most of their work subconsciously, instead of consciously. It&#8217;s like when you learn to drive a car (assuming you learned on a manual transmission). First you have a set of steps that you must follow, and repeat. Then you begin to follow patterns. (I used to look at my current speed to decide whether to shift gears.) Then you stop thinking about it, and you just drive.

> A human uses mechanical weights and machines in a gym to increase his innate capabilities &#8211; to make his own muscles strong and more reliable. Using a more cerebral metaphor (and one therefore more appropriate for object thinking), Kent Beck suggest using method and even XP practices as if they were etudes (musical exercises designed to help the musician internalize certain skills and techniques.)

Time and Focus equates to discipline, according to me.&#160; In order to excel at something you need to invest both time and focus to truly excel at it. There really is no secret to getting better.

> A common tendency for new object developers is to list as responsibilities things that an object must "know." An airplane must "know its current location." While this may be true, it can be misleading. It implies too much about how the object might be implemented because "knows" implies an instance variable. It&#8217;s also quite possible that an object will know things (a private key for decryption, perhaps) that it will not be willing to share with others and that therefore will not be included in the interface for that object. _Provide private key_ would not appear as a service, although the message _privateKey_ might be in the object&#8217;s protocol with the designation that it is a private message. _Decrypt message_, on the other hand, might be a listed responsibility. Always state your responsibilities in terms of a service, with an awareness of a possible client for that service.

I know when I first started transitioning from procedural to object oriented programming, I thought mostly about where and how the data was going to stored, and how to get the data. "This auditor class needs to have a sorted list of audits"&#8230; Now it&#8217;s a little more like "An auditor can submit an audit of a company to &#8230;"

This was a great read for anyone wanting to get into objects, or learn more about the history of objects. It was great to read about were a lot of present day ideas originated from.